{% extends "base.html" %}

{% block main_content %}
<style>
  .loading-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 70vh;
    text-align: center;
  }

  .loading-message h2 {
    margin-bottom: 10px;
    color: #4a90e2;
  }

  .loading-message p {
    color: #888;
  }

  .pdf-nav {
    display: flex;
    gap: 2rem;
    justify-content: center;
    margin: 0.5rem 0;
  }

  .pdf-nav a {
    display: none;
    background: #ffffffcc;
    color: #222;
    padding: 0.4rem 0.75rem;
    border-radius: 6px;
    text-decoration: none;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
  }

  .pdf-nav a:active {
    transform: translateY(1px);
  }

  .pdf-header {
    background: rgba(31, 41, 55, 0.5);
    border: 1px solid rgba(55, 65, 81, 0.5);
    border-radius: 8px;
    padding: 1rem 1.5rem;
    margin-top: 1rem;
    margin-bottom: 1rem;
    backdrop-filter: blur(10px);
  }

  .pdf-header h1 {
    margin: 0.5rem 0 0 0;
    font-size: 1.25rem;
    color: #f3f4f6;
    font-weight: 600;
  }

  .pdf-header h1::before {
    content: '';
  }

  .pdf-breadcrumb {
    display: flex;
    align-items: center;
    font-size: 1rem;
    color: #9ca3af;
    flex-wrap: wrap;
  }

  .pdf-breadcrumb a {
    color: #10b981;
    transition: color 0.2s;
    font-size: 1rem;
    background-color: inherit;
    position: relative;
    text-decoration: none;
    /* we'll render an animated underline using ::after */
  }

  /* Animated underline using a pseudo-element so we can transition it smoothly */
  .pdf-breadcrumb a::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: -2px;
    height: 2px;
    width: 100%;
    background-color: #059669;
    /* same as hover color */
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.18s ease, opacity 0.18s ease;
    opacity: 0;
    pointer-events: none;
  }

  .pdf-breadcrumb a:hover,
  .pdf-breadcrumb a:focus-visible {
    color: #059669;
    text-decoration: none;
  }

  .pdf-breadcrumb a:hover::after,
  .pdf-breadcrumb a:focus-visible::after {
    transform: scaleX(1);
    opacity: 1;
  }

  .pdf-breadcrumb .separator {
    color: #6b7280;
    user-select: none;
    font-size: 1rem;
  }

  .pdf-breadcrumb .current {
    font-size: 1rem;
  }

  .pdf-breadcrumb .current {
    color: #f3f4f6;
  }
</style>

<!-- Include login component for session management -->
{% include "components/login.html" %}

<div id="pdf-header" class="pdf-header" style="display: none;">
  <div class="pdf-breadcrumb" id="pdf-breadcrumb">
    <a href="/">Home</a>
    <span class="separator" style="margin: 0 0.5rem;">/</span>
    <span id="breadcrumb-content">Loading...</span>
  </div>
  <h1 id="pdf-title">Loading...</h1>
</div>

<div id="pdf-container">
  <div class="loading-message">
    <h2>Loading document...</h2>
    <p>Verifying access permissions...</p>
  </div>
</div><br>

<div class="pdf-nav" aria-hidden="true">
  <a id="pdf-prev" href="#" title="Previous document">← Prev</a>
  <a id="pdf-next" href="#" title="Next document">Next →</a>
</div><br>

<script type="module">
  import { API_BASE_URL } from '/js/utils.js?v={{ config.extra.sw_version }}';
  window.API_BASE_URL = API_BASE_URL;

  // Global variables for navigation
  let pdfPath, semester, subjectCode, unit, filename, title, normalizedPdfPath;

  document.addEventListener('DOMContentLoaded', async function () {
    if (!sessionStorage.getItem('user_session')) { localStorage.setItem('postLoginRedirect', window.location.href); }

    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    pdfPath = urlParams.get('file');
    title = urlParams.get('title'); // Get title from URL parameter first

    // Check if file param is a semantic path
    if (pdfPath && !pdfPath.startsWith('http') && !pdfPath.startsWith('/api/')) {
      // Parse semantic path from file parameter
      const pathParts = pdfPath.split('/').filter(Boolean);

      // Pattern A: sem-N/<subject>/unit-N/<filename>
      if (pathParts.length === 4) {
        const semMatch = pathParts[0].match(/^sem-(\d+)$/);
        const unitMatch = pathParts[2].match(/^unit-(\d+)$/);
        if (semMatch && unitMatch) {
          semester = semMatch[1];
          subjectCode = pathParts[1];
          unit = unitMatch[1];
          filename = decodeURIComponent(pathParts[3]);
          if (!title) title = filename.replace(/^\d+_/, '').replace(/\.[^.]+$/, '').replace(/_/g, ' ');
          pdfPath = `${API_BASE_URL}/api/resources/sem-${semester}/${subjectCode}/unit-${unit}/${encodeURIComponent(filename)}`;
        }
      }

      // Pattern B (all-units): sem-N/<subject>/<type>/unit-all/<filename>
      else if (pathParts.length === 5) {
        const semMatch = pathParts[0].match(/^sem-(\d+)$/);
        const typeSegment = pathParts[2];
        const isAllUnit = pathParts[3] === 'unit-all';
        if (semMatch && isAllUnit) {
          semester = semMatch[1];
          subjectCode = pathParts[1];
          const resourceType = typeSegment; // keep as-is (QA, Notes, etc.)
          unit = 'all';
          filename = decodeURIComponent(pathParts[4]);
          if (!title) title = filename.replace(/^\d+_/, '').replace(/\.[^.]+$/, '').replace(/_/g, ' ');
          pdfPath = `${API_BASE_URL}/api/resources/sem-${semester}/${subjectCode}/${resourceType}/unit-all/${encodeURIComponent(filename)}`;
        }
      }
    }

    // If pdfPath is a relative /api/ path, make it absolute with API_BASE_URL
    if (pdfPath && pdfPath.startsWith('/api/') && !pdfPath.startsWith('http')) {
      pdfPath = API_BASE_URL + pdfPath;
    }

    // Fallback: check for legacy query parameters (only if not already set)
    if (!subjectCode) subjectCode = urlParams.get('subjectCode');
    if (!unit) unit = urlParams.get('unit');
    if (!semester) {
      semester = urlParams.get('semester');
      // Extract semester from path if not in params
      if (!semester && pdfPath) {
        const semMatch = pdfPath.match(/sem-(\d+)/i);
        if (semMatch) semester = semMatch[1];
      }
    }
    // Keep pdfPath as-is since it's now a full URL with API_BASE_URL
    // The loadPdfViewer function will handle cross-origin fetching
    let normalizedPdfPath = pdfPath;
    // Helper: extract resource id from a /api/resources/<id>/stream style path
    function extractResourceId(path) {
      if (!path) return null;
      try {
        const u = new URL(path, window.location.href);
        const parts = u.pathname.split('/').filter(Boolean);
        const idx = parts.indexOf('resources');
        if (idx !== -1 && parts.length > idx + 1) return parts[idx + 1];
      } catch (e) {
        const m = String(path).match(/api\/resources\/([-a-f0-9]{8,})/i);
        if (m) return m[1];
      }
      return null;
    }

    // Ensure we have a stream token in sessionStorage for the given resource id.
    // This calls the /api/mint-stream-token endpoint (server must validate
    // that the caller is authenticated). If successful, token is stored under
    // sessionStorage['stream_token'] for use by the viewer.
    async function ensureStreamToken(resourceId) {
      if (!resourceId) return;
      if (sessionStorage.getItem('stream_token')) return;
      try {
        const sessionStr = sessionStorage.getItem('user_session');
        const headers = { 'Content-Type': 'application/json' };
        if (sessionStr) {
          try {
            const sess = JSON.parse(sessionStr);
            // If your auth flow stores access token here, include it (optional).
            if (sess && (sess.access_token || sess.token)) {
              headers['Authorization'] = 'Bearer ' + (sess.access_token || sess.token);
            }
          } catch (e) { /* ignore parse errors */ }
        }

        // Send credentials so cookies (HttpOnly) are forwarded by the browser.
        const resp = await fetch(`${API_BASE_URL}/api/mint-stream-token`, { method: 'POST', headers, credentials: 'include', body: JSON.stringify({ id: resourceId, ttl: 600 }) });
        if (!resp.ok) {
          console.warn('ensureStreamToken: mint endpoint failed', resp.status);
          return;
        }
        const j = await resp.json().catch(() => null);
        if (j && j.token) sessionStorage.setItem('stream_token', j.token);
      } catch (e) {
        console.warn('ensureStreamToken error', e);
      }
    }
    // Before attempting to append a token, try to mint one for this resource
    // (if the user is authenticated). Then append whatever token we have.
    try {
      const resourceId = extractResourceId(normalizedPdfPath || pdfPath);
      await ensureStreamToken(resourceId);

      const sessionToken = sessionStorage.getItem('stream_token');
      if (sessionToken && normalizedPdfPath) {
        try {
          const u = new URL(normalizedPdfPath, window.location.href);
          if (!u.searchParams.get('token') && u.pathname.startsWith('/api/resources/')) {
            u.searchParams.set('token', sessionToken);
            if (u.origin === window.location.origin) {
              normalizedPdfPath = u.pathname + (u.search || '');
            } else {
              normalizedPdfPath = u.href;
            }
          }
        } catch (e) {
          // ignore URL parsing errors
        }
      }
    } catch (e) {
      // sessionStorage or network may be unavailable in some contexts
    }

    // Update page title
    if (title) {
      document.title = title;
    }

    // Update PDF header
    const pdfHeaderEl = document.getElementById('pdf-header');
    const pdfTitleEl = document.getElementById('pdf-title');
    const breadcrumbContentEl = document.getElementById('breadcrumb-content');

    if (title) {
      pdfTitleEl.textContent = title;
    }

    // Fetch subject name from API instead of hardcoded mapping
    let displaySubject = null;
    let displaySubjectCode = subjectCode;

    // Fallback: extract from path for legacy URLs
    if (!displaySubjectCode && pdfPath) {
      const extractedSubject = extractSubjectFromPath(pdfPath);
      if (extractedSubject) {
        displaySubjectCode = extractedSubject.toLowerCase();
      }
    }

    // Fetch subject name from API if we have a subject code
    if (displaySubjectCode) {
      try {
        const apiUrl = `${API_BASE_URL}/api/subject/resources?subject=${encodeURIComponent(displaySubjectCode)}`;
        const resp = await fetch(apiUrl, { cache: 'no-store' });
        if (resp.ok) {
          const data = await resp.json();
          displaySubject = data.subjectName || displaySubjectCode.toUpperCase();
        } else {
          displaySubject = displaySubjectCode.toUpperCase();
        }
      } catch (e) {
        console.warn('Failed to fetch subject name from API, using fallback', e);
        displaySubject = displaySubjectCode.toUpperCase();
      }
    }

    let displayUnit = unit;

    // Build breadcrumb navigation
    let breadcrumbHTML = '';

    if (displaySubject && displaySubjectCode) {
      // Link to subject page using /sem-N/subject-code format
      const semesterPath = semester ? `/sem-${semester}/${displaySubjectCode}/` : `/#subject-${displaySubjectCode}`;
      breadcrumbHTML += `<a href="${semesterPath}">${displaySubject}</a>`;

      if (displayUnit) {
        breadcrumbHTML += `<span class="separator" style="margin: 0 0.5rem;">/</span>`;
        breadcrumbHTML += `<a href="${semesterPath}">Unit ${displayUnit}</a>`;
      }

      if (title) {
        breadcrumbHTML += `<span class="separator" style="margin: 0 0.5rem;">/</span>`;
        breadcrumbHTML += `<span class="current">${title}</span>`;
      }
    } else if (title) {
      breadcrumbHTML = `<span class="current">${title}</span>`;
    }

    if (breadcrumbHTML) {
      breadcrumbContentEl.innerHTML = breadcrumbHTML;
    }

    // Show header if we have title
    if (title) {
      pdfHeaderEl.style.display = 'block';
    }

    if (!pdfPath) {
      document.getElementById('pdf-container').innerHTML = '<h2>Error: No file specified</h2>';
      if (window.posthog) {
        posthog.capture('pdf_viewer_error', {
          error: 'No file specified',
          url: window.location.href
        });
      }
      return;
    }

    async function checkPdfAvailable(path) {
      try {
        // If we already created a blob URL for the PDF, assume it's available.
        if (typeof path === 'string' && path.startsWith('blob:')) {
          return { ok: true, status: 200, contentType: 'application/pdf' };
        }
        // Use document location as base so relative paths resolve correctly,
        // and absolute URLs (including blob: and other origins) are preserved.
        const absUrl = new URL(path, window.location.href).href;
        // Try HEAD first (small, efficient)
        let r = await fetch(absUrl, { method: 'HEAD', cache: 'no-store' });
        if (r.ok) {
          const newToken = r.headers.get('X-Stream-Token') || r.headers.get('x-stream-token');
          if (newToken) try { sessionStorage.setItem('stream_token', newToken); } catch (e) { }
          return { ok: true, status: r.status, contentType: r.headers.get('content-type') };
        }
        // Some servers reject HEAD -> try a tiny GET with Range to minimize data
        r = await fetch(absUrl, {
          method: 'GET',
          headers: { 'Range': 'bytes=0-0' },
          cache: 'no-store',
          credentials: 'include'
        });
        if (r.ok || r.status === 206) {
          const newToken = r.headers.get('X-Stream-Token') || r.headers.get('x-stream-token');
          if (newToken) try { sessionStorage.setItem('stream_token', newToken); } catch (e) { }
          return { ok: true, status: r.status, contentType: r.headers.get('content-type') };
        }
        return { ok: false, status: r.status, statusText: r.statusText };
      } catch (err) {
        return { ok: false, error: err.message || String(err) };
      }
    }

    function showPdfError(message, details) {
      const container = document.getElementById('pdf-container');
      container.innerHTML = `
            <div class="loading-message" role="alert">
                <h2>Unable to load document</h2>
                <p>${message}</p>
                <p style="color:#aaa;font-size:0.9rem">${details || ''}</p>
            </div>
        `;
      if (window.posthog) {
        posthog.capture('pdf_view_error', {
          pdf_path: pdfPath,
          error_message: message,
          details: details || null,
          url: window.location.href
        });
      }
    }

    // Session validation is handled by login.js and login.html
    // If session is valid, login.js will show content and hide login modal
    // If not, login modal will be shown and access denied handled there

    // Load PDF viewer if session is valid (login.js will handle showing/hiding)
    async function loadPdfViewer() {
      // Since pdfPath is now a full URL with API_BASE_URL, we need to fetch it
      // and create a blob URL for PDF.js (avoids cross-origin issues)
      let fileToUse = normalizedPdfPath || pdfPath;

      try {
        // If fileToUse is a full URL (which it should be), fetch and blob it
        if (fileToUse && (fileToUse.startsWith('http://') || fileToUse.startsWith('https://'))) {
          try {
            const resp = await fetch(fileToUse, { cache: 'no-store', credentials: 'include' });
            if (resp.ok) {
              // Validate PDF signature before creating blob URL to avoid pdf.js "Invalid PDF structure" later.
              // We read a small slice instead of full blob first.
              const ab = await resp.arrayBuffer();
              if (ab.byteLength < 8) {
                console.warn('PDF fetch returned too few bytes');
              }
              const headerBytes = new Uint8Array(ab.slice(0, 8));
              const isPdf = headerBytes[0] === 0x25 && // %
                headerBytes[1] === 0x50 && // P
                headerBytes[2] === 0x44 && // D
                headerBytes[3] === 0x46 && // F
                headerBytes[4] === 0x2D;   // -
              if (!isPdf) {
                console.error('File does not appear to be a PDF (missing %PDF- signature).');
                showPdfError('File is not a valid PDF.', 'Missing %PDF- header.');
                return; // abort viewer load
              }
              // Create blob URL from validated buffer
              const blob = new Blob([ab], { type: 'application/pdf' });
              const blobUrl = URL.createObjectURL(blob);
              fileToUse = blobUrl;
            } else {
              console.warn('fetch for PDF failed', resp.status);
            }
          } catch (e) {
            console.warn('fetch failed', e);
          }
        }
      } catch (e) {
        // ignore errors and use original fileToUse
      }

      // check availability first (use resolved fileToUse)
      const info = await checkPdfAvailable(fileToUse);
      if (!info.ok) {
        const msg = info.status ? `HTTP ${info.status} ${info.statusText || ''}` : (info.error || 'File not found or network error');
        showPdfError('The requested PDF could not be found or accessed.', `${msg}`);
        console.warn('PDF check failed', info);
        return;
      }

      let pdfViewerUrl = `/pdfjs/web/viewer.html?file=${encodeURIComponent(fileToUse)}`;
      try {
        const orig = (title && title.trim()) ? title.trim() : null;
        if (orig) pdfViewerUrl += `&origFilename=${encodeURIComponent(orig)}`;
      } catch (e) { }
      document.getElementById('pdf-container').innerHTML = `
      <div style="width: 100%; height: 90vh;">
        <iframe src="${pdfViewerUrl}" 
            style="width: 100%; height: 100%; border: none;"
            allow="fullscreen">
          <p>Loading PDF viewer...</p>
        </iframe>
      </div>
    `;

      // Track PDF view with PostHog
      const sessionData = sessionStorage.getItem('user_session');
      if (window.posthog && sessionData) {
        try {
          const session = JSON.parse(sessionData);

          // Only send PII if user has not opted out
          if (window.isPIITrackingAllowed && window.isPIITrackingAllowed()) {
            posthog.identify(session.srn, {
              srn: session.srn,
              name: session.profile.name || session.srn,
              branch: session.profile?.branch,
              semester: session.profile?.semester,
              is_pwa: window.matchMedia('(display-mode: standalone)').matches
            });
            posthog.capture('pdf_viewed', {
              pdf_path: pdfPath,
              pdf_title: title || 'Unknown',
              file_name: pdfPath.split('/').pop(),
              subject: extractSubjectFromPath(pdfPath),
              unit: extractUnitFromPath(pdfPath),
              view_timestamp: new Date().toISOString(),
              referrer: document.referrer,
              is_pwa: window.matchMedia('(display-mode: standalone)').matches
            });
          } else {
            // Track PDF view without PII when opted out
            posthog.capture('pdf_viewed', {
              pdf_title: title || 'Unknown',
              subject: extractSubjectFromPath(pdfPath),
              unit: extractUnitFromPath(pdfPath),
              view_timestamp: new Date().toISOString(),
              is_pwa: window.matchMedia('(display-mode: standalone)').matches
            });
          }
        } catch (error) {
          console.error('PostHog tracking error:', error);
        }
      }
    }

    // Extract subject from file path
    function extractSubjectFromPath(path) {
      const match = path.match(/\/(wd|cfp|mp|mfca|pce|ciep)\//i);
      return match ? match[1].toUpperCase() : 'Unknown';
    }

    // Extract unit from file path
    function extractUnitFromPath(path) {
      const match = path.match(/unit[-_]?(\d+)/i);
      return match ? `Unit ${match[1]}` : 'Unknown';
    }

    // Build navigation using API
    async function buildNav() {
      try {
        const prevBtn = document.getElementById('pdf-prev');
        const nextBtn = document.getElementById('pdf-next');

        console.debug('buildNav (API-driven): start', { subjectCode, filename, semester });

        // We need subjectCode and filename to build navigation
        if (!subjectCode || !filename) {
          console.debug('buildNav: missing subjectCode or filename for navigation');
          return;
        }

        // Fetch all resources for this subject from the API
        const apiUrl = `${API_BASE_URL}/api/subject/resources?subject=${encodeURIComponent(subjectCode)}`;
        const resp = await fetch(apiUrl, { cache: 'no-store' });

        if (!resp.ok) {
          console.warn('buildNav: API fetch failed', resp.status);
          return;
        }

        const data = await resp.json();
        if (!data.resources) {
          console.warn('buildNav: no resources in API response');
          return;
        }

        // Flatten all resources from units -> resource_types -> resources
        const files = [];
        for (const [unitNum, types] of Object.entries(data.resources)) {
          for (const [type, resources] of Object.entries(types)) {
            for (const resource of resources) {
              files.push(resource);
            }
          }
        }

        if (!files.length) {
          console.debug('buildNav: no files found for subject', subjectCode);
          return;
        }

        // Sort files by unit number, then by leading number in filename
        files.sort((a, b) => {
          // First, sort by unit
          const unitA = parseInt(a.unit) || 999;
          const unitB = parseInt(b.unit) || 999;
          if (unitA !== unitB) return unitA - unitB;

          // Then sort by leading number in filename
          const aFilename = a.filename || '';
          const bFilename = b.filename || '';
          const aMatch = aFilename.match(/^(\d+)/);
          const bMatch = bFilename.match(/^(\d+)/);
          const aNum = aMatch ? parseInt(aMatch[1]) : 999999;
          const bNum = bMatch ? parseInt(bMatch[1]) : 999999;

          return aNum - bNum;
        });

        // Find index of current file by filename
        const idx = files.findIndex(f => f.filename === filename);
        if (idx === -1) {
          console.debug('buildNav: current file not found in resources', filename);
          return;
        }

        // Navigation buttons
        if (prevBtn && idx > 0) {
          const prev = files[idx - 1];
          {
            const prevPath = prev.url ? null : `sem-${semester}/${subjectCode}/unit-${prev.unit}/${encodeURIComponent(prev.filename || '')}`;
            prevBtn.href = prev.url || `/pdf-viewer?file=${encodeURIComponent(prevPath)}&title=${encodeURIComponent((prev.title || prev.filename || '').toString())}`;
          }
          prevBtn.innerText = '← ' + (prev.title || prev.filename || 'Prev');
          prevBtn.title = (prev.title || prev.filename || 'Previous document');
          prevBtn.style.display = 'inline-block';
          prevBtn.setAttribute('aria-hidden', 'false');
        }
        if (nextBtn && idx < files.length - 1) {
          const next = files[idx + 1];
          {
            const nextPath = next.url ? null : `sem-${semester}/${subjectCode}/unit-${next.unit}/${encodeURIComponent(next.filename || '')}`;
            nextBtn.href = next.url || `/pdf-viewer?file=${encodeURIComponent(nextPath)}&title=${encodeURIComponent((next.title || next.filename || '').toString())}`;
          }
          nextBtn.innerText = (next.title || next.filename || 'Next') + ' →';
          nextBtn.title = (next.title || next.filename || 'Next document');
          nextBtn.style.display = 'inline-block';
          nextBtn.setAttribute('aria-hidden', 'false');
        }
      } catch (err) {
        console.warn('buildNav (API-driven) failed', err);
      }
    }

    // Load PDF viewer if session is valid (login.js will handle session check)
    // You may want to expose a global callback for login.js to call loadPdfViewer() after successful login
    window.loadPdfViewer = loadPdfViewer;

    // Optionally, try to load PDF if already logged in
    if (sessionStorage.getItem('logged_in') === 'true' && typeof window.loadPdfViewer === 'function') {
      window.loadPdfViewer();
    }

    // Build navigation after variables are set
    buildNav();
  });
</script>
{% endblock main_content %}